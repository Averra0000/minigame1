<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    const TZ = { w: 150, h: 150, ox: 110, oy: -65 };

    let bar1 = 0, bar2 = 0;
    let isGameOver = false;
    
    let waterPos = { x: 0, y: 0 };
    
    // --- 优化核心：引入物理变量 ---
    let velocity = { x: 0, y: 0 }; // 当前速度
    const accel = 0.8;             // 加速度：数值越小移动越精细
    const friction = 0.88;          // 摩擦力：数值越接近1越滑，越小越稳
    
    let drift = { x: 0, y: 0 }; 
    const keys = {};
    let particles = [];

    const winSound = new Audio('win.mp3');
    const failSound = new Audio('fail.mp3');

    // 粒子类保持不变...
    class Drip {
        constructor() {
            this.progress = 0;
            this.speed = 0.05 + Math.random() * 0.02;
            this.startX = canvas.width / 2;
            this.startY = canvas.height + 20;
            this.tx = waterPos.x + (Math.random()-0.5) * 15;
            this.ty = waterPos.y + (Math.random()-0.5) * 15;
        }
        update() {
            this.progress += this.speed;
            this.currX = this.startX + (this.tx - this.startX) * this.progress;
            this.currY = this.startY + (this.ty - this.startY) * this.progress - Math.sin(this.progress * Math.PI) * 120;
        }
        draw() {
            let size = 1 + (1 - this.progress) * 10;
            ctx.fillStyle = `rgba(0, 212, 255, ${1 - this.progress})`;
            ctx.beginPath(); ctx.arc(this.currX, this.currY, size, 0, Math.PI * 2); ctx.fill();
        }
    }

    function init() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        waterPos.x = (canvas.width / 2) + TZ.ox;
        waterPos.y = (canvas.height / 2) + TZ.oy;
    }
    window.addEventListener('resize', init);
    init();

    window.addEventListener('keydown', e => keys[e.key.toLowerCase()] = true);
    window.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);

    function loop() {
        if (isGameOver) return;

        // 1. 随机漂移：降低频率，增强“晃动”感
        drift.x += (Math.random() - 0.5) * 1.2;
        drift.y += (Math.random() - 0.5) * 1.2;
        velocity.x += drift.x * 0.1; // 漂移影响速度
        velocity.y += drift.y * 0.1;
        drift.x *= 0.9;
        drift.y *= 0.9;

        // 2. 平滑操控：使用加速度控制速度
        if (keys['w'] || keys['arrowup'])    velocity.y -= accel;
        if (keys['s'] || keys['arrowdown'])  velocity.y += accel;
        if (keys['a'] || keys['arrowleft'])  velocity.x -= accel;
        if (keys['d'] || keys['arrowright']) velocity.x += accel;

        // 3. 应用摩擦力（这是丝滑的关键）
        velocity.x *= friction;
        velocity.y *= friction;

        // 4. 更新最终位置
        waterPos.x += velocity.x;
        waterPos.y += velocity.y;

        for(let i=0; i<3; i++) particles.push(new Drip());

        const tx = (canvas.width / 2) - (TZ.w / 2) + TZ.ox;
        const ty = (canvas.height / 2) - (TZ.h / 2) + TZ.oy;
        const inTarget = waterPos.x > tx && waterPos.x < tx + TZ.w &&
                         waterPos.y > ty && waterPos.y < ty + TZ.h;
        
        if (inTarget) bar1 += 0.22; else bar2 += 0.55;

        ctx.clearRect(0, 0, canvas.width, canvas.height);

        particles.forEach((p, i) => {
            p.update(); p.draw();
            if (p.progress >= 1) particles.splice(i, 1);
        });

        // 绘制带“软边缘”的高亮落点
        const gradient = ctx.createRadialGradient(waterPos.x, waterPos.y, 0, waterPos.x, waterPos.y, 15);
        gradient.addColorStop(0, 'rgba(0, 212, 255, 1)');
        gradient.addColorStop(1, 'rgba(0, 212, 255, 0)');
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(waterPos.x, waterPos.y, 15, 0, Math.PI * 2);
        ctx.fill();

        document.getElementById('pee-fill').style.width = Math.min(bar1, 100) + '%';
        document.getElementById('floor-fill').style.width = Math.min(bar2, 100) + '%';
        document.getElementById('p1').innerText = Math.floor(bar1) + '%';
        document.getElementById('p2').innerText = Math.floor(bar2) + '%';

        if (bar1 >= 100) { winSound.play().catch(e=>{}); setTimeout(() => { alert("SUCCESS!"); location.reload(); }, 100); isGameOver = true; }
        if (bar2 >= 100) { failSound.play().catch(e=>{}); setTimeout(() => { alert("FAILED!"); location.reload(); }, 100); isGameOver = true; }

        requestAnimationFrame(loop);
    }
    requestAnimationFrame(loop);
</script>
