<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <title>Aim Game - God Mode Aligner</title>
    <style>
        body { 
            margin: 0; overflow: hidden; background: #000; color: white; font-family: sans-serif; 
            background-image: url('bg.jpg'); background-size: cover; background-position: center;
        }
        canvas { display: block; }
        .ui { position: absolute; top: 20px; left: 20px; width: 280px; pointer-events: none; opacity: 0.6; }
        .bar-container { background: rgba(0, 0, 0, 0.7); padding: 10px; border-radius: 8px; margin-bottom: 5px; border: 1px solid #444; }
        .progress { background: #1a1a1a; height: 10px; border-radius: 5px; overflow: hidden; }
        #pee-fill { height: 100%; background: #00d4ff; width: 0%; }
        #floor-fill { height: 100%; background: #005a7a; width: 0%; }

        /* 调试控制台 - 允许交互 */
        #debug-panel {
            position: absolute; right: 20px; top: 20px; background: rgba(0,0,0,0.9); 
            padding: 15px; border-radius: 10px; border: 2px solid gold; z-index: 100;
            display: flex; flex-direction: column; gap: 8px; width: 200px;
        }
        .debug-row { display: flex; justify-content: space-between; align-items: center; font-size: 12px; }
        .debug-btn { padding: 4px 8px; cursor: pointer; background: #333; color: white; border: 1px solid #666; font-size: 14px; }
        .debug-btn:hover { background: #555; }
        .status { color: #0f0; font-weight: bold; text-align: center; margin-bottom: 5px; }
    </style>
</head>
<body>

    <div id="debug-panel">
        <div class="status" id="debug-status">调试模式: 游戏已暂停</div>
        <div style="font-size: 10px; color: #aaa;">1. 点击按钮对齐背景方框<br>2. 调准后记下下方数值</div>
        <hr>
        <div class="debug-row">位置 Y: 
            <button class="debug-btn" onclick="adj('oy', -5)">↑</button>
            <button class="debug-btn" onclick="adj('oy', 5)">↓</button>
        </div>
        <div class="debug-row">位置 X: 
            <button class="debug-btn" onclick="adj('ox', -5)">←</button>
            <button class="debug-btn" onclick="adj('ox', 5)">→</button>
        </div>
        <div class="debug-row">宽度 W: 
            <button class="debug-btn" onclick="adj('w', -5)">-</button>
            <button class="debug-btn" onclick="adj('w', 5)">+</button>
        </div>
        <div class="debug-row">高度 H: 
            <button class="debug-btn" onclick="adj('h', -5)">-</button>
            <button class="debug-btn" onclick="adj('h', 5)">+</button>
        </div>
        <hr>
        <div id="final-vals" style="font-family: monospace; font-size: 11px; background: #222; padding: 5px;"></div>
        <button onclick="toggleGame()" style="background: gold; color: black; border: none; padding: 5px; cursor: pointer; font-weight: bold;">开始/暂停 判定</button>
    </div>

    <div class="ui">
        <div class="bar-container"><div>PEE BAR</div><div class="progress"><div id="pee-fill"></div></div></div>
        <div class="bar-container"><div>FLOOR BAR</div><div class="progress"><div id="floor-fill"></div></div></div>
    </div>

    <canvas id="gameCanvas"></canvas>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    // --- 初始配置 (这就是你要通过按钮找出的数值) ---
    let TZ = { w: 150, h: 150, ox: 0, oy: -80 };
    let gameRunning = false; // 默认暂停，方便你调试

    let bar1 = 0, bar2 = 0, isGameOver = false;
    let waterPos = { x: 0, y: 0 };
    let drift = { x: 0, y: 0 };
    const keys = {};
    let particles = [];

    function adj(type, val) {
        if(type === 'ox') TZ.ox += val;
        if(type === 'oy') TZ.oy += val;
        if(type === 'w') TZ.w += val;
        if(type === 'h') TZ.h += val;
        updateUI();
    }

    function toggleGame() {
        gameRunning = !gameRunning;
        document.getElementById('debug-status').innerText = gameRunning ? "判定模式: 运行中" : "调试模式: 游戏已暂停";
        document.getElementById('debug-status').style.color = gameRunning ? "gold" : "#0f0";
    }

    function updateUI() {
        document.getElementById('final-vals').innerText = `w: ${TZ.w}, h: ${TZ.h}\nox: ${TZ.ox}, oy: ${TZ.oy}`;
    }

    class Drip {
        constructor() {
            this.progress = 0;
            this.speed = 0.05 + Math.random() * 0.02;
            this.startX = canvas.width / 2;
            this.startY = canvas.height + 20;
            this.tx = waterPos.x + (Math.random()-0.5) * 15;
            this.ty = waterPos.y + (Math.random()-0.5) * 15;
        }
        update() {
            this.progress += this.speed;
            this.currX = this.startX + (this.tx - this.startX) * this.progress;
            this.currY = this.startY + (this.ty - this.startY) * this.progress - Math.sin(this.progress * Math.PI) * 120;
        }
        draw() {
            let size = 1 + (1 - this.progress) * 8;
            ctx.fillStyle = `rgba(0, 212, 255, ${1 - this.progress})`;
            ctx.beginPath(); ctx.arc(this.currX, this.currY, size, 0, Math.PI * 2); ctx.fill();
        }
    }

    function init() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        waterPos.x = canvas.width / 2;
        waterPos.y = canvas.height / 2 + TZ.oy;
        updateUI();
    }
    window.addEventListener('resize', init);
    init();

    window.addEventListener('keydown', e => keys[e.key.toLowerCase()] = true);
    window.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);

    function loop() {
        if (isGameOver) return;

        // 只有按键时水柱才会受控移动
        const moveSpeed = 7;
        if (keys['w'] || keys['arrowup'])    waterPos.y -= moveSpeed;
        if (keys['s'] || keys['arrowdown'])  waterPos.y += moveSpeed;
        if (keys['a'] || keys['arrowleft'])  waterPos.x -= moveSpeed;
        if (keys['d'] || keys['arrowright']) waterPos.x += moveSpeed;

        for(let i=0; i<3; i++) particles.push(new Drip());

        const tx = (canvas.width / 2) - (TZ.w / 2) + TZ.ox;
        const ty = (canvas.height / 2) - (TZ.h / 2) + TZ.oy;

        if (gameRunning) {
            const inTarget = waterPos.x > tx && waterPos.x < tx + TZ.w &&
                             waterPos.y > ty && waterPos.y < ty + TZ.h;
            if (inTarget) bar1 += 0.2; else bar2 += 0.6;
            
            if (bar1 >= 100 || bar2 >= 100) isGameOver = true;
        }

        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // 1. 目标框 (调试用)
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
        ctx.lineWidth = 2;
        ctx.strokeRect(tx, ty, TZ.w, TZ.h);

        // 2. 路径粒子
        particles.forEach((p, i) => {
            p.update(); p.draw();
            if (p.progress >= 1) particles.splice(i, 1);
        });

        // 3. 高亮接触点 (像第一版那样)
        ctx.shadowBlur = 15;
        ctx.shadowColor = "#00d4ff";
        ctx.fillStyle = "rgba(0, 212, 255, 0.8)";
        ctx.beginPath();
        ctx.arc(waterPos.x, waterPos.y, 8, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0; // 重置阴影

        document.getElementById('pee-fill').style.width = Math.min(bar1, 100) + '%';
        document.getElementById('floor-fill').style.width = Math.min(bar2, 100) + '%';

        requestAnimationFrame(loop);
    }
    requestAnimationFrame(loop);
</script>
</body>
</html>
